<!DOCTYPE HTML>
<html lang="fr">
<head>
<!-- Generated by javadoc (18) -->
<title>gov.nasa.jpl.aerie.json (parsing-utilities 0.13.0-SNAPSHOT-228d8672d API)</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="description" content="declaration: package: gov.nasa.jpl.aerie.json">
<meta name="generator" content="javadoc/PackageWriterImpl">
<link rel="stylesheet" type="text/css" href="../../../../../stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../../../script-dir/jquery-ui.min.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../../../jquery-ui.overrides.css" title="Style">
<script type="text/javascript" src="../../../../../script.js"></script>
<script type="text/javascript" src="../../../../../script-dir/jquery-3.5.1.min.js"></script>
<script type="text/javascript" src="../../../../../script-dir/jquery-ui.min.js"></script>
</head>
<body class="package-declaration-page">
<script type="text/javascript">var evenRowColor = "even-row-color";
var oddRowColor = "odd-row-color";
var tableTab = "table-tab";
var activeTableTab = "active-table-tab";
var pathtoroot = "../../../../../";
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<div class="flex-box">
<header role="banner" class="flex-header">
<nav role="navigation">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="top-nav" id="navbar-top"><button id="navbar-toggle-button" aria-controls="navbar-top" aria-expanded="false" aria-label="Toggle navigation links"><span class="nav-bar-toggle-icon"></span><span class="nav-bar-toggle-icon"></span><span class="nav-bar-toggle-icon"></span></button>
<div class="skip-nav"><a href="#skip-navbar-top" title="Skip navigation links">Skip navigation links</a></div>
<ul id="navbar-top-firstrow" class="nav-list" title="Navigation">
<li class="nav-bar-cell1-rev">Package</li>
<li>Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../../index-all.html">Index</a></li>
<li><a href="../../../../../help-doc.html#package">Help</a></li>
</ul>
<ul class="sub-nav-list-small">
<li>
<p>Package:</p>
<ul>
<li><a href="#package-description">Description</a></li>
<li>Related Packages</li>
<li><a href="#class-summary">Classes and Interfaces</a></li>
</ul>
</li>
</ul>
</div>
<div class="sub-nav">
<div id="navbar-sub-list">
<ul class="sub-nav-list">
<li>Package:&nbsp;</li>
<li><a href="#package-description">Description</a>&nbsp;|&nbsp;</li>
<li>Related Packages&nbsp;|&nbsp;</li>
<li><a href="#class-summary">Classes and Interfaces</a></li>
</ul>
</div>
<div class="nav-list-search"><label for="search-input">SEARCH:</label>
<input type="text" id="search-input" disabled placeholder="Search">
<input type="reset" id="reset-button" disabled value="reset">
</div>
</div>
<!-- ========= END OF TOP NAVBAR ========= -->
<span class="skip-nav" id="skip-navbar-top"></span></nav>
</header>
<div class="flex-content">
<main role="main">
<div class="header">
<h1 title="Package gov.nasa.jpl.aerie.json" class="title">Package gov.nasa.jpl.aerie.json</h1>
</div>
<hr>
<div class="package-signature">package <span class="element-name">gov.nasa.jpl.aerie.json</span></div>
<section class="package-description" id="package-description">
<div class="block">A toolkit for authoring bidirectional JSON parsers with parser combinators.

 <p> This library provides the basic building blocks for defining serialization formats for any Java type,
 together with "parsers" which can convert both to and from these formats. A format is defined grammatically, by
 composing simpler pre-existing formats into more complex assemblies with the help of general-purpose combiners.
 We prioritize ease-of-use and expressivity over efficiency: parsers defined with this library may be slower than
 those defined with other libraries, but our goal is for them to be more maintainable in certain dimensions
 than alternatives. </p>

 <p> We take the position that serialization is a separate and orthogonal concern from domain modeling. Domain types
 ought not favor a particular mode of serialization, as business needs can easily change over time. Formats can be
 authored using this library without any need to modify the domain types they operate on. Moreover, where other
 libraries may infer details about the serialization format by inspecting the class definitions of domain types, we
 accept some potential overhead in repeating ourselves to cleanly separate the concern of what <i>developers</i> call
 a field from what <i>clients</i> call it -- and whether their data is structually organized the same way at all. </p>

 <p> We <b>eschew reflection and convention</b> in favor of explicit control over how Java values are modeled in JSON.
 Other libraries may require little to no configuration by relying on reflection and convention, but needs outside
 the happy path begin to look very different (and ad-hoc) from where you started. This library tries to provide a
 uniform and consistent authoring experience: if you can author a simple format, odds are you know everything you need
 to author a much more complex format. </p>

 <p> At the same time, we provide a flexible foundation for building custom parsing logic. It is entirely possible
 to define a reflection-based parser as a custom implementation of <a href="JsonParser.html" title="interface in gov.nasa.jpl.aerie.json"><code>JsonParser</code></a>, then
 use it as a building block just like any of the provided parsers. Custom needs of any kind need only implement
 that interface. </p>

 <p> Lastly, we do not parse JSON documents out of strings, but rather work with values of
 type <code>javax.json.JsonValue</code>. Any library that produces and consumes these values can be used to bridge the
 last gap from this library to the filesystem or network. </p>

 <h2> Defining a format </h2>

 <p> As a running example, consider the type of expressions below, which models a DSL of operations on integers
 and strings. (Note in particular that expressions are classified into integer-valued expressions and string-valued
 expressions.) This DSL may admit multiple serialized representations, such as a traditional infix representation
 (<code>#(1 + 1) .. "3"</code>) and a tree-formatted JSON representation, so we do not want to privilege one
 representation by implementing it as a method on the expression type itself.</p>

 
<div class="snippet-container"><button class="snippet-copy" onclick="copySnippet(this)"><span data-copied="Copied!">Copy</span><img src="../../../../../copy.svg" alt="Copy"></button>
<pre class="snippet"><code>public sealed interface Expr&lt;T&gt; {
  record Num(int value) implements Expr&lt;Integer&gt; {}
  record Negate(Expr&lt;Integer&gt; operand) implements Expr&lt;Integer&gt; {}
  record Add(Expr&lt;Integer&gt; left, Expr&lt;Integer&gt; right) implements Expr&lt;Integer&gt; {}

  record Str(String value) implements Expr&lt;String&gt; {}
  record ToString(Expr&lt;Integer&gt; operand) implements Expr&lt;String&gt; {}
  record Concat(Expr&lt;String&gt; left, Expr&lt;String&gt; right) implements Expr&lt;String&gt; {}
}</code></pre>
</div>


 <p> A JSON format for this type must capture the top-level alternatives amongst the kinds of expression,
 the mid-level group of fields within each alternative, and the base-level recursion back to the top. In fact,
 most types can be thought of as a sum (alternatives) of products (fields) of other types; when the "other type"
 is our original type, we have recursion. Often, there is only one option or only one field, so this hierarchy
 simplifies for many types. </p>

 <p> Because almost any compound type can be modeled as a sum of products, this library provides general-purpose
 combiners for describing formats that follow this structure. You may build custom combiners for special needs,
 or even build parsers without using combiners at all -- especially when working with types that do not break down
 into independent pieces in this way -- but the provided combiners should be useful in most cases. </p>

 <p> Now, let's see how to build up a parser for our <code>Expr</code> type.</p>

 
<div class="snippet-container"><button class="snippet-copy" onclick="copySnippet(this)"><span data-copied="Copied!">Copy</span><img src="../../../../../copy.svg" alt="Copy"></button>
<pre class="snippet"><code>final JsonParser&lt;Expr.Num&gt; numP
  = intP
  . map(Expr.Num::new, Expr.Num::value);

final JsonParser&lt;Expr.Str&gt; strP
  = stringP
  . map(Expr.Str::new, Expr.Str::value));</code></pre>
</div>


 <p> The <a href="BasicParsers.html#intP"><code>BasicParsers.intP</code></a> and <a href="BasicParsers.html#stringP"><code>BasicParsers.stringP</code></a>
 parsers are provided by <a href="BasicParsers.html" title="class in gov.nasa.jpl.aerie.json"><code>BasicParsers</code></a>, and can be statically imported for brevity.
 They work with the <code>Integer</code> and <code>String</code> type, respectively. In order to adapt these to our custom
 <code>Expr</code> subclasses, we use the <a href="JsonParser.html#map(gov.nasa.jpl.aerie.json.Convert)"><code>JsonParser.map(gov.nasa.jpl.aerie.json.Convert&lt;T, S&gt;)</code></a> helper method, which takes two
 functions: a conversion to the new type from the current type, and a conversion from the new type back to the current
 type. Here, we are only constructing and deconstructing a wrapper around a single value.  </p>

 
<div class="snippet-container"><button class="snippet-copy" onclick="copySnippet(this)"><span data-copied="Copied!">Copy</span><img src="../../../../../copy.svg" alt="Copy"></button>
<pre class="snippet"><code>static JsonObjectParser&lt;Expr.Negate&gt; negateP(final JsonParser&lt;Expr&lt;Integer&gt;&gt; integerExprP) {
  return productP
      . field("operand", integerExprP)
      . map(Expr.Negate::new, Expr.Negate::operand);
}

static JsonObjectParser&lt;Expr.ToString&gt; toStringP(final JsonParser&lt;Expr&lt;Integer&gt;&gt; integerExprP) {
  return productP
      . field("operand", integerExprP)
      . map(Expr.ToString::new, Expr.ToString::operand);
}</code></pre>
</div>


 <p> Our next two parsers depend on a parser we haven't defined yet -- the top-level integer expression and string
 expression parsers. Since the top-level parsers, in turn, depend on these individual parsers, we will have a cyclic
 dependency to handle no matter where we started. Instead of defining these parsers immediately, we <i>defer</i>
 their construction until later, passing it the top-level parser as an argument once we have it. (We'll see how to close
 the cycle momentarily.) </p>

 <p> In addition, notice that we are using the <a href="BasicParsers.html#productP"><code>BasicParsers.productP</code></a> combiner here --
 which specifies a JSON object whose fields are described by other parsers -- rather than using <code>integerExprP</code>
 directly. There are two reasons for this! First, we want parsers to be "productive", which means that they should
 consume some part of the input before descending into a subparser. This is not always a hard-and-fast rule, but since
 our grammar is recursive, we <i>must</i> make progress on the input before cycling back to the same point in the
 grammar. Otherwise, we will have an infinite loop on our hands! </p>

 <p> The other reason not to use `integerExprP` directly is because the operators described by these parsers are
 simply two of many, and we need a way to distinguish these options from the others. When we collect these parsers
 together into one parser of alternatives, we will extend them with an additional "op" field taking on a unique value.
 Notice that these methods return a <a href="JsonObjectParser.html" title="interface in gov.nasa.jpl.aerie.json"><code>JsonObjectParser</code></a> rather than the more generic
 <a href="JsonParser.html" title="interface in gov.nasa.jpl.aerie.json"><code>JsonParser</code></a>: the former allows the format to be extended with additional fields. </p>

 
<div class="snippet-container"><button class="snippet-copy" onclick="copySnippet(this)"><span data-copied="Copied!">Copy</span><img src="../../../../../copy.svg" alt="Copy"></button>
<pre class="snippet"><code>static JsonParser&lt;Expr&lt;Integer&gt;&gt; integerExprP(final JsonParser&lt;Expr&lt;Integer&gt;&gt; integerExprP) {
  @SuppressWarnings("unchecked")
  final var intExprClass = (Class&lt;Expr&lt;Integer&gt;&gt;) (Object) Expr.class;

  return chooseP(
      numP,
      sumP("op", intExprClass, List.of(
          new Variant&lt;&gt;("+", Expr.Add.class, addP(integerExprP)),
          new Variant&lt;&gt;("-", Expr.Negate.class, negateP(integerExprP))
      )));
}

final JsonParser&lt;Expr&lt;Integer&gt;&gt; integerExprP
    = recursiveP(selfP -&gt; integerExprP(selfP));</code></pre>
</div>


 <p> Here, <code>integerExprP</code> is defined as a method. Just like the previous parsers, its construction depends on
 a parser that doesn't exist yet -- only, in this case, it depends on itself.
 The <a href="BasicParsers.html#recursiveP(java.util.function.Function)"><code>BasicParsers.recursiveP(java.util.function.Function)</code></a> combiner ties the knot on
 such a dependency cycle, feeding the given factory function a handle to a mutable location that <i>will</i>,
 eventually, contain a valid parser -- but only once the factory returns one. For this reason, it is important that
 the factory not <i>invoke</i> the provided parser, only use it to construct a bigger (productive!) parser. </p>

 <p> The <code>integerExprP</code> parser itself is built using two different combiners for handling alternatives.
 The first, <a href="BasicParsers.html#chooseP(gov.nasa.jpl.aerie.json.JsonParser...)"><code>BasicParsers.chooseP(gov.nasa.jpl.aerie.json.JsonParser[])</code></a>, models
 an untagged sum: it can't tell immediately which alternative a particular JSON document is a representation of,
 so it attempts each subparser in turn until it finds one that works. It is very easy to accidentally define
 overlapping alternatives; be careful to ensure that values covered by one alternative are not covered
 by another! </p>

 <p> The <a href="SumParsers.html#sumP(java.lang.String,java.lang.Class,java.util.List)"><code>SumParsers.sumP(java.lang.String, java.lang.Class, java.util.List)</code></a> combiner,
 on the other hand, is a tagged sum: it associates to every alternative an extra field, whose fixed value is distinct
 for each alternative. This makes it fast and reliable to determine which subparser reigns for a particular document,
 but makes it less general than <code>chooseP</code>. The <code>sumP</code> combiner is also specialized to situations where
 the domain types are described by a subclass hierarchy; it cannot be used for modeling, say,
 <a href="https://docs.oracle.com/en/java/javase/18/docs/api/java.base/java/util/Optional.html" title="class or interface in java.util" class="external-link"><code>Optional</code></a>, whose alternatives are not detected with <code>instanceof</code>. </p>

 <p> Our expression parser uses <code>sumP</code> to describe operations using an "op" field, whose value (either "+" or
 "-") determines the remaining fields. We use <code>chooseP</code> to allow numbers to be written directly, rather than
 wrapping them in an extra object like the other cases. The alternatives under <code>chooseP</code> have no overlap in
 either the JSON format or the Java type hierarchy, so this is a safe use of <code>chooseP</code>. </p>

 <p> The case for string expressions is directly analogous: </p>

 
<div class="snippet-container"><button class="snippet-copy" onclick="copySnippet(this)"><span data-copied="Copied!">Copy</span><img src="../../../../../copy.svg" alt="Copy"></button>
<pre class="snippet"><code>static JsonParser&lt;Expr&lt;String&gt;&gt; stringExprP(final JsonParser&lt;Expr&lt;String&gt;&gt; stringExprP) {
  @SuppressWarnings("unchecked")
  final var stringExprClass = (Class&lt;Expr&lt;String&gt;&gt;) (Object) Expr.class;

  return chooseP(
      strP,
      sumP("op", stringExprClass, List.of(
          new Variant&lt;&gt;("++", Expr.Concat.class, concatP(stringExprP)),
          new Variant&lt;&gt;("$", Expr.ToString.class, toStringP(integerExprP))
      )));
}

final JsonParser&lt;Expr&lt;String&gt;&gt; stringExprP
    = recursiveP(selfP -&gt; stringExprP(selfP));</code></pre>
</div>


 <p> Now, if <code>stringExprP</code> models the root of our expression grammar, we can invoke
 <a href="JsonParser.html#parse(javax.json.JsonValue)"><code>JsonParser.parse(javax.json.JsonValue)</code></a> on it to convert a JSON document into an
 <code>Expr&lt;String&gt;</code>, or invoke <a href="JsonParser.html#unparse(T)"><code>JsonParser.unparse(java.lang.Object)</code></a> to convert
 an <code>Expr&lt;String&gt;</code> into a JSON document. As a bonus, the <a href="JsonParser.html#getSchema()"><code>JsonParser.getSchema()</code></a>
 method will produce a JSON Schema-compliant document describing the class of JSON documents modeled by
 this parser! </p></div>
</section>
<section class="summary">
<ul class="summary-list">
<li>
<div id="class-summary">
<div class="table-tabs" role="tablist" aria-orientation="horizontal"><button id="class-summary-tab0" role="tab" aria-selected="true" aria-controls="class-summary.tabpanel" tabindex="0" onkeydown="switchTab(event)" onclick="show('class-summary', 'class-summary', 2)" class="active-table-tab">All Classes and Interfaces</button><button id="class-summary-tab1" role="tab" aria-selected="false" aria-controls="class-summary.tabpanel" tabindex="-1" onkeydown="switchTab(event)" onclick="show('class-summary', 'class-summary-tab1', 2)" class="table-tab">Interfaces</button><button id="class-summary-tab2" role="tab" aria-selected="false" aria-controls="class-summary.tabpanel" tabindex="-1" onkeydown="switchTab(event)" onclick="show('class-summary', 'class-summary-tab2', 2)" class="table-tab">Classes</button><button id="class-summary-tab3" role="tab" aria-selected="false" aria-controls="class-summary.tabpanel" tabindex="-1" onkeydown="switchTab(event)" onclick="show('class-summary', 'class-summary-tab3', 2)" class="table-tab">Enum Classes</button><button id="class-summary-tab4" role="tab" aria-selected="false" aria-controls="class-summary.tabpanel" tabindex="-1" onkeydown="switchTab(event)" onclick="show('class-summary', 'class-summary-tab4', 2)" class="table-tab">Record Classes</button></div>
<div id="class-summary.tabpanel" role="tabpanel">
<div class="summary-table two-column-summary" aria-labelledby="class-summary-tab0">
<div class="table-header col-first">Class</div>
<div class="table-header col-last">Description</div>
<div class="col-first even-row-color class-summary class-summary-tab2"><a href="BasicParsers.html" title="class in gov.nasa.jpl.aerie.json">BasicParsers</a></div>
<div class="col-last even-row-color class-summary class-summary-tab2">
<div class="block">A namespace for primitive parsers and essential combinators.</div>
</div>
<div class="col-first odd-row-color class-summary class-summary-tab2"><a href="Breadcrumb.html" title="class in gov.nasa.jpl.aerie.json">Breadcrumb</a></div>
<div class="col-last odd-row-color class-summary class-summary-tab2">&nbsp;</div>
<div class="col-first even-row-color class-summary class-summary-tab1"><a href="Breadcrumb.BreadcrumbVisitor.html" title="interface in gov.nasa.jpl.aerie.json">Breadcrumb.BreadcrumbVisitor</a>&lt;Result&gt;</div>
<div class="col-last even-row-color class-summary class-summary-tab1">&nbsp;</div>
<div class="col-first odd-row-color class-summary class-summary-tab1"><a href="Convert.html" title="interface in gov.nasa.jpl.aerie.json">Convert</a>&lt;S,<wbr>T&gt;</div>
<div class="col-last odd-row-color class-summary class-summary-tab1">
<div class="block">An infallible two-way conversion between types <code>S</code> and <code>T</code>.</div>
</div>
<div class="col-first even-row-color class-summary class-summary-tab1"><a href="JsonObjectParser.html" title="interface in gov.nasa.jpl.aerie.json">JsonObjectParser</a>&lt;T&gt;</div>
<div class="col-last even-row-color class-summary class-summary-tab1">&nbsp;</div>
<div class="col-first odd-row-color class-summary class-summary-tab1"><a href="JsonParser.html" title="interface in gov.nasa.jpl.aerie.json">JsonParser</a>&lt;T&gt;</div>
<div class="col-last odd-row-color class-summary class-summary-tab1">
<div class="block">An interface for two-way conversion between JSON documents and domain objects.</div>
</div>
<div class="col-first even-row-color class-summary class-summary-tab1"><a href="JsonParseResult.html" title="interface in gov.nasa.jpl.aerie.json">JsonParseResult</a>&lt;T&gt;</div>
<div class="col-last even-row-color class-summary class-summary-tab1">&nbsp;</div>
<div class="col-first odd-row-color class-summary class-summary-tab4"><a href="JsonParseResult.Failure.html" title="class in gov.nasa.jpl.aerie.json">JsonParseResult.Failure</a>&lt;T&gt;</div>
<div class="col-last odd-row-color class-summary class-summary-tab4">&nbsp;</div>
<div class="col-first even-row-color class-summary class-summary-tab4"><a href="JsonParseResult.FailureReason.html" title="class in gov.nasa.jpl.aerie.json">JsonParseResult.FailureReason</a></div>
<div class="col-last even-row-color class-summary class-summary-tab4">&nbsp;</div>
<div class="col-first odd-row-color class-summary class-summary-tab4"><a href="JsonParseResult.Success.html" title="class in gov.nasa.jpl.aerie.json">JsonParseResult.Success</a>&lt;T&gt;</div>
<div class="col-last odd-row-color class-summary class-summary-tab4">&nbsp;</div>
<div class="col-first even-row-color class-summary class-summary-tab2"><a href="PathJsonParser.html" title="class in gov.nasa.jpl.aerie.json">PathJsonParser</a></div>
<div class="col-last even-row-color class-summary class-summary-tab2">&nbsp;</div>
<div class="col-first odd-row-color class-summary class-summary-tab2"><a href="ProductParsers.html" title="class in gov.nasa.jpl.aerie.json">ProductParsers</a></div>
<div class="col-last odd-row-color class-summary class-summary-tab2">&nbsp;</div>
<div class="col-first even-row-color class-summary class-summary-tab2"><a href="ProductParsers.EmptyProductParser.html" title="class in gov.nasa.jpl.aerie.json">ProductParsers.EmptyProductParser</a></div>
<div class="col-last even-row-color class-summary class-summary-tab2">&nbsp;</div>
<div class="col-first odd-row-color class-summary class-summary-tab2"><a href="ProductParsers.VariadicProductParser.html" title="class in gov.nasa.jpl.aerie.json">ProductParsers.VariadicProductParser</a>&lt;T&gt;</div>
<div class="col-last odd-row-color class-summary class-summary-tab2">&nbsp;</div>
<div class="col-first even-row-color class-summary class-summary-tab2"><a href="SchemaCache.html" title="class in gov.nasa.jpl.aerie.json">SchemaCache</a></div>
<div class="col-last even-row-color class-summary class-summary-tab2">&nbsp;</div>
<div class="col-first odd-row-color class-summary class-summary-tab2"><a href="SumParsers.html" title="class in gov.nasa.jpl.aerie.json">SumParsers</a></div>
<div class="col-last odd-row-color class-summary class-summary-tab2">&nbsp;</div>
<div class="col-first even-row-color class-summary class-summary-tab4"><a href="SumParsers.Variant.html" title="class in gov.nasa.jpl.aerie.json">SumParsers.Variant</a>&lt;T&gt;</div>
<div class="col-last even-row-color class-summary class-summary-tab4">&nbsp;</div>
<div class="col-first odd-row-color class-summary class-summary-tab2"><a href="Uncurry.html" title="class in gov.nasa.jpl.aerie.json">Uncurry</a></div>
<div class="col-last odd-row-color class-summary class-summary-tab2">
<div class="block">A set of utility functions for transforming the fields of an object parser.</div>
</div>
<div class="col-first even-row-color class-summary class-summary-tab1"><a href="Uncurry.Function3.html" title="interface in gov.nasa.jpl.aerie.json">Uncurry.Function3</a>&lt;Result,<wbr>T1,<wbr>T2,<wbr>T3&gt;</div>
<div class="col-last even-row-color class-summary class-summary-tab1">&nbsp;</div>
<div class="col-first odd-row-color class-summary class-summary-tab1"><a href="Uncurry.Function4.html" title="interface in gov.nasa.jpl.aerie.json">Uncurry.Function4</a>&lt;Result,<wbr>T1,<wbr>T2,<wbr>T3,<wbr>T4&gt;</div>
<div class="col-last odd-row-color class-summary class-summary-tab1">&nbsp;</div>
<div class="col-first even-row-color class-summary class-summary-tab1"><a href="Uncurry.Function5.html" title="interface in gov.nasa.jpl.aerie.json">Uncurry.Function5</a>&lt;Result,<wbr>T1,<wbr>T2,<wbr>T3,<wbr>T4,<wbr>T5&gt;</div>
<div class="col-last even-row-color class-summary class-summary-tab1">&nbsp;</div>
<div class="col-first odd-row-color class-summary class-summary-tab1"><a href="Uncurry.Function6.html" title="interface in gov.nasa.jpl.aerie.json">Uncurry.Function6</a>&lt;Result,<wbr>T1,<wbr>T2,<wbr>T3,<wbr>T4,<wbr>T5,<wbr>T6&gt;</div>
<div class="col-last odd-row-color class-summary class-summary-tab1">&nbsp;</div>
<div class="col-first even-row-color class-summary class-summary-tab1"><a href="Uncurry.Function7.html" title="interface in gov.nasa.jpl.aerie.json">Uncurry.Function7</a>&lt;Result,<wbr>T1,<wbr>T2,<wbr>T3,<wbr>T4,<wbr>T5,<wbr>T6,<wbr>T7&gt;</div>
<div class="col-last even-row-color class-summary class-summary-tab1">&nbsp;</div>
<div class="col-first odd-row-color class-summary class-summary-tab1"><a href="Uncurry.Function8.html" title="interface in gov.nasa.jpl.aerie.json">Uncurry.Function8</a>&lt;Result,<wbr>T1,<wbr>T2,<wbr>T3,<wbr>T4,<wbr>T5,<wbr>T6,<wbr>T7,<wbr>T8&gt;</div>
<div class="col-last odd-row-color class-summary class-summary-tab1">&nbsp;</div>
<div class="col-first even-row-color class-summary class-summary-tab3"><a href="Unit.html" title="enum class in gov.nasa.jpl.aerie.json">Unit</a></div>
<div class="col-last even-row-color class-summary class-summary-tab3">
<div class="block">A type with only one non-null value.</div>
</div>
</div>
</div>
</div>
</li>
</ul>
</section>
</main>
</div>
</div>
</body>
</html>
