/**********
SCHEDULING CONDITION
***********/
/*
METADATA
*/
create table scheduling_condition_metadata (
  id integer generated by default as identity,

  name text not null,
  description text not null default '',
  public boolean not null default false,

  owner text,
  updated_by text,

  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),

  constraint scheduling_condition_metadata_pkey
    primary key (id)
);

-- A partial index is used to enforce name uniqueness only on conditions visible to other users
create unique index condition_name_unique_if_published on scheduling_condition_metadata (name) where public;

comment on table scheduling_condition_metadata is e''
  'A condition restricting scheduling of a plan.';
comment on column scheduling_condition_metadata.id is e''
  'The unique identifier for this scheduling condition.';
comment on column scheduling_condition_metadata.name is e''
  'A short human readable name for this condition';
comment on column scheduling_condition_metadata.description is e''
  'A longer text description of this scheduling condition.';
comment on column scheduling_condition_metadata.public is e''
  'Whether this goal is visible to all users.';
comment on column scheduling_condition_metadata.owner is e''
  'The user responsible for this condition.';
comment on column scheduling_condition_metadata.updated_by is e''
  'The user who last modified this condition''s metadata.';
comment on column scheduling_condition_metadata.created_at is e''
  'The time at which this condition was created.';
comment on column scheduling_condition_metadata.updated_at is e''
  'The time at which this condition''s metadata was last modified.';

/*
DEFINITION
*/
create table scheduling_condition_definition(
  condition_id integer not null,
  revision integer not null default 0,
  definition text not null,
  author text,
  created_at timestamptz not null default now(),

  constraint scheduling_condition_definition_pkey
    primary key (condition_id, revision),
  constraint scheduling_condition_definition_condition_exists
    foreign key (condition_id)
    references scheduling_condition_metadata
    on update cascade
    on delete cascade
);

comment on table scheduling_condition_definition is e''
  'The specific revisions of a scheduling condition''s definition';
comment on column scheduling_condition_definition.revision is e''
  'An identifier of this definition.';
comment on column scheduling_condition_definition.definition is e''
  'An executable expression in the Merlin scheduling language.';
comment on column scheduling_condition_definition.author is e''
  'The user who authored this revision.';
comment on column scheduling_condition_definition.created_at is e''
  'When this revision was created.';

create function scheduling_condition_definition_set_revision()
returns trigger
volatile
language plpgsql as $$
declare
  max_revision integer;
begin
  -- Grab the current max value of revision, or -1, if this is the first revision
  select coalesce((select revision
  from scheduling_condition_definition
  where condition_id = new.condition_id
  order by revision desc
  limit 1), -1)
  into max_revision;

  new.revision = max_revision + 1;
  return new;
end
$$;

create trigger scheduling_goal_definition_set_revision
  before insert on scheduling_condition_definition
  for each row
  execute function scheduling_condition_definition_set_revision();

/*
TAGS
*/
create table metadata.scheduling_condition_tags (
  condition_id integer references public.scheduling_condition_metadata
    on update cascade
    on delete cascade,
  tag_id integer not null,
  primary key (condition_id, tag_id)
);
comment on table metadata.scheduling_condition_tags is e''
  'The tags associated with a scheduling condition.';

create table metadata.scheduling_condition_definition_tags (
  condition_id integer not null,
  condition_revision integer not null,
  tag_id integer not null,
  primary key (condition_id, condition_revision, tag_id),
  foreign key (condition_id, condition_revision) references scheduling_condition_definition
    on update cascade
    on delete cascade
);

comment on table metadata.scheduling_condition_definition_tags is e''
  'The tags associated with a specific scheduling condition definition.';

/*
SPECIFICATIONS
*/
create table scheduling_model_specification_conditions(
  model_id integer not null,
  condition_id integer not null,
  condition_revision integer, -- latest is NULL

  primary key (model_id, condition_id),
  foreign key (condition_id)
    references scheduling_condition_metadata
    on update cascade
    on delete restrict,
  foreign key (condition_id, condition_revision)
    references scheduling_condition_definition
    on update cascade
    on delete restrict
);

comment on table scheduling_model_specification_conditions is e''
'The set of scheduling conditions that all plans using the model should include in their scheduling specification.';
comment on column scheduling_model_specification_conditions.model_id is e''
'The model which this specification is for. Half of the primary key.';
comment on column scheduling_model_specification_conditions.condition_id is e''
'The id of a specific scheduling condition in the specification. Half of the primary key.';
comment on column scheduling_model_specification_conditions.condition_revision is e''
'The version of the scheduling condition definition to use. Leave NULL to use the latest version.';

alter table scheduling_specification_conditions
  add column condition_revision integer,
  -- This constraint's name is too long
  drop constraint scheduling_specification_conditions_references_scheduling_specification,
  add constraint scheduling_specification_conditions_specification_exists
    foreign key (specification_id)
     references scheduling_specification
     on update cascade
     on delete cascade;

comment on table scheduling_specification_conditions is e''
  'The set of scheduling conditions to be used on a given plan.';
comment on column scheduling_specification_conditions.specification_id is e''
  'The plan scheduling specification which this condition is on. Half of the primary key.';
comment on column scheduling_specification_conditions.condition_id is e''
  'The ID of a specific condition in the specification. Half of the primary key.';
comment on column scheduling_specification_conditions.condition_revision is e''
  'The version of the condition definition to use. Leave NULL to use the latest version.';
comment on column scheduling_specification_conditions.enabled is e''
  'Whether to use a given condition. Defaults to TRUE.';

create function increment_spec_revision_on_conditions_spec_update()
  returns trigger
  security definer
language plpgsql as $$
begin
  update scheduling_specification
  set revision = revision + 1
  where id = new.specification_id;
  return new;
end;
$$;

create trigger increment_revision_on_condition_update
  before insert or update on scheduling_specification_conditions
  for each row
  execute function increment_spec_revision_on_conditions_spec_update();

create function increment_spec_revision_on_conditions_spec_delete()
  returns trigger
  security definer
language plpgsql as $$
begin
  update scheduling_specification
  set revision = revision + 1
  where id = new.specification_id;
  return new;
end;
$$;

create trigger increment_revision_on_condition_delete
  before delete on scheduling_specification_conditions
  for each row
  execute function increment_spec_revision_on_conditions_spec_delete();

/*
DATA MIGRATION
*/
insert into scheduling_condition_metadata(id, name, description, public, owner, updated_by, created_at, updated_at)
select id, name, description, false, author, last_modified_by, created_date, modified_date
from scheduling_condition;

insert into scheduling_condition_definition(condition_id, definition, author, created_at)
select id, definition, author, modified_date
from scheduling_condition;

insert into scheduling_model_specification_conditions(model_id, condition_id)
select model_id, id
from scheduling_condition;

/*
POST DATA MIGRATION TABLE CHANGES
*/
alter table scheduling_condition_metadata
  alter column id set generated always;

create function scheduling_condition_metadata_set_updated_at()
returns trigger
security definer
language plpgsql as $$begin
  new.updated_at = now();
  return new;
end$$;

create trigger set_timestamp
before update on scheduling_condition_metadata
for each row
execute function scheduling_condition_metadata_set_updated_at();

alter table scheduling_specification_conditions
  drop constraint scheduling_specification_conditions_references_scheduling_conditions,
  add constraint scheduling_specification_condition_exists
    foreign key (condition_id)
      references scheduling_condition_metadata
      on update cascade
      on delete restrict,
  add constraint scheduling_specification_condition_definition_exists
    foreign key (condition_id, condition_revision)
     references scheduling_condition_definition
     on update cascade
     on delete restrict;

/*
DROP ORIGINAL
*/
drop trigger update_logging_on_update_scheduling_condition_trigger on scheduling_condition;
drop function update_logging_on_update_scheduling_condition();
drop table scheduling_condition;

/**********
SCHEDULING GOALS
***********/
/*
METADATA
*/
create table scheduling_goal_metadata (
  id integer generated by default as identity,

  name text not null,
  description text not null default '',
  public boolean not null default false,

  owner text,
  updated_by text,

  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),

  constraint scheduling_goal_metadata_pkey
    primary key (id)
);

-- A partial index is used to enforce name uniqueness only on goals visible to other users
create unique index goal_name_unique_if_published on scheduling_goal_metadata (name) where public;

comment on table scheduling_goal_metadata is e''
  'A goal for scheduling a plan.';
comment on column scheduling_goal_metadata.id is e''
  'The unique identifier of the goal';
comment on column scheduling_goal_metadata.name is e''
  'A human-meaningful name.';
comment on column scheduling_goal_metadata.description is e''
  'A detailed description suitable for long-form documentation.';
comment on column scheduling_goal_metadata.public is e''
  'Whether this goal is visible to all users.';
comment on column scheduling_goal_metadata.owner is e''
  'The user responsible for this goal.';
comment on column scheduling_goal_metadata.updated_by is e''
  'The user who last modified this goal''s metadata.';
comment on column scheduling_goal_metadata.created_at is e''
  'The time at which this goal was created.';
comment on column scheduling_goal_metadata.updated_at is e''
  'The time at which this goal''s metadata was last modified.';

/*
DEFINITION
*/
create table scheduling_goal_definition(
  goal_id integer not null,
  revision integer not null default 0,

  definition text not null,
  author text,
  created_at timestamptz not null default now(),

  constraint scheduling_goal_definition_pkey
    primary key (goal_id, revision),
  constraint scheduling_goal_definition_goal_exists
    foreign key (goal_id)
    references scheduling_goal_metadata
    on update cascade
    on delete cascade
);

comment on table scheduling_goal_definition is e''
  'The specific revisions of a scheduling goal''s definition';
comment on column scheduling_goal_definition.revision is e''
  'An identifier of this definition.';
comment on column scheduling_goal_definition.definition is e''
  'An executable expression in the Merlin scheduling language.';
comment on column scheduling_goal_definition.author is e''
  'The user who authored this revision.';
comment on column scheduling_goal_definition.created_at is e''
  'When this revision was created.';

create function scheduling_goal_definition_set_revision()
returns trigger
volatile
language plpgsql as $$
declare
  max_revision integer;
begin
  -- Grab the current max value of revision, or -1, if this is the first revision
  select coalesce((select revision
  from scheduling_goal_definition
  where goal_id = new.goal_id
  order by revision desc
  limit 1), -1)
  into max_revision;

  new.revision = max_revision + 1;
  return new;
end
$$;

create trigger scheduling_goal_definition_set_revision
  before insert on scheduling_goal_definition
  for each row
  execute function scheduling_goal_definition_set_revision();

/*
SPECIFICATIONS
*/
create table scheduling_model_specification_goals(
  model_id integer not null,
  goal_id integer not null,
  goal_revision integer, -- latest is NULL
  priority integer not null,

  primary key (model_id, goal_id),
  foreign key (goal_id)
    references scheduling_goal_metadata
    on update cascade
    on delete restrict,
  foreign key (goal_id, goal_revision)
    references scheduling_goal_definition
    on update cascade
    on delete restrict,
  constraint model_spec_unique_goal_priorities
    unique (model_id, priority) deferrable initially deferred,
  constraint model_spec_nonnegative_priority
    check (priority >= 0)
);

comment on table scheduling_model_specification_goals is e''
'The set of scheduling goals that all plans using the model should include in their scheduling specification.';
comment on column scheduling_model_specification_goals.model_id is e''
'The model which this specification is for. Half of the primary key.';
comment on column scheduling_model_specification_goals.goal_id is e''
'The id of a specific scheduling goal in the specification. Half of the primary key.';
comment on column scheduling_model_specification_goals.goal_revision is e''
'The version of the scheduling goal definition to use. Leave NULL to use the latest version.';
comment on column scheduling_model_specification_goals.priority is e''
  'The relative priority of the scheduling goal in relation to other goals on the same specification.';

create function insert_scheduling_model_specification_goal_func()
  returns trigger
  language plpgsql as $$
  declare
    next_priority integer;
begin
  select coalesce(
    (select priority
     from scheduling_model_specification_goals smg
     where smg.model_id = new.model_id
     order by priority desc
     limit 1), -1) + 1
  into next_priority;

  if new.priority > next_priority then
    raise numeric_value_out_of_range using
      message = ('Updated priority % for model_id % is not consecutive', new.priority, new.model_id),
      hint = ('The next available priority is %.', next_priority);
  end if;

  if new.priority is null then
    new.priority = next_priority;
  end if;

  update scheduling_model_specification_goals
  set priority = priority + 1
  where model_id = new.model_id
    and priority >= new.priority;
  return new;
end;
$$;

comment on function insert_scheduling_model_specification_goal_func() is e''
  'Checks that the inserted priority is consecutive, and reorders (increments) higher or equal priorities to make room.';

create trigger insert_scheduling_model_specification_goal
  before insert
  on scheduling_model_specification_goals
  for each row
execute function insert_scheduling_model_specification_goal_func();

create function update_scheduling_model_specification_goal_func()
  returns trigger
  language plpgsql as $$
  declare
    next_priority integer;
begin
  select coalesce(
    (select priority
     from scheduling_model_specification_goals smg
     where smg.model_id = new.model_id
     order by priority desc
     limit 1), -1) + 1
  into next_priority;

  if new.priority > next_priority then
    raise numeric_value_out_of_range using
      message = ('Updated priority % for model_id % is not consecutive', new.priority, new.model_id),
      hint = ('The next available priority is %.', next_priority);
  end if;

  if new.priority > old.priority then
    update scheduling_model_specification_goals
    set priority = priority - 1
    where model_id = new.model_id
      and priority between old.priority + 1 and new.priority
      and goal_id != new.goal_id;
  else
    update scheduling_model_specification_goals
    set priority = priority + 1
    where model_id = new.model_id
      and priority between new.priority and old.priority - 1
      and goal_id != new.goal_id;
  end if;
  return new;
end;
$$;

comment on function update_scheduling_model_specification_goal_func() is e''
  'Checks that the updated priority is consecutive, and reorders priorities to make room.';

create trigger update_scheduling_model_specification_goal
  before update
  on scheduling_model_specification_goals
  for each row
  when (OLD.priority is distinct from NEW.priority and pg_trigger_depth() < 1)
execute function update_scheduling_model_specification_goal_func();

create function delete_scheduling_model_specification_goal_func()
  returns trigger
  language plpgsql as $$
begin
  update scheduling_model_specification_goals
  set priority = priority - 1
  where model_id = old.model_id
    and priority > old.priority;
  return null;
end;
$$;

comment on function delete_scheduling_model_specification_goal_func() is e''
  'Reorders (decrements) priorities to fill the gap from deleted priority.';

create trigger delete_scheduling_model_specification_goal
  after delete
  on scheduling_model_specification_goals
  for each row
execute function delete_scheduling_model_specification_goal_func();

alter table scheduling_specification_goals
  add column goal_revision integer,
  alter column priority drop default,
  alter column enabled set not null,
  -- This constraint's name is too long
  drop constraint scheduling_specification_goals_references_scheduling_specification,
  add constraint scheduling_specification_goals_specification_exists
    foreign key (specification_id)
      references scheduling_specification
      on update cascade
      on delete cascade,
  drop constraint scheduling_specification_unique_goal_id;

comment on table scheduling_specification_goals is e''
  'The scheduling goals to be executed against a given plan.';
comment on column scheduling_specification_goals.specification_id is e''
  'The plan scheduling specification this goal is on. Half of the primary key.';
comment on column scheduling_specification_goals.goal_id is e''
  'The id of a specific goal in the specification. Half of the primary key.';
comment on column scheduling_specification_goals.goal_revision is e''
  'The version of the goal definition to use. Leave NULL to use the latest version.';
comment on column scheduling_specification_goals.priority is e''
  'The relative priority of a scheduling goal in relation to other '
  'scheduling goals within the same specification.';
comment on column scheduling_specification_goals.enabled is e''
  'Whether to run a given goal. Defaults to TRUE.';
comment on column scheduling_specification_goals.simulate_after is e''
  'Whether to re-simulate after evaluating this goal and before the next goal.';

create or replace function insert_scheduling_specification_goal_func()
  returns trigger
  language plpgsql as $$
  declare
    next_priority integer;
begin
  select coalesce(
    (select priority
     from scheduling_specification_goals ssg
     where ssg.specification_id = new.specification_id
     order by priority desc
     limit 1), -1) + 1
  into next_priority;

  if new.priority > next_priority then
    raise numeric_value_out_of_range using
      message = ('Updated priority % for specification_id % is not consecutive', new.priority, new.specification_id),
      hint = ('The next available priority is %.', next_priority);
  end if;

  if new.priority is null then
    new.priority = next_priority;
  end if;

  update scheduling_specification_goals
  set priority = priority + 1
  where specification_id = new.specification_id
    and priority >= new.priority;
  return new;
end;
$$;

create or replace function update_scheduling_specification_goal_func()
  returns trigger
  language plpgsql as $$
  declare
    next_priority integer;
begin
  select coalesce(
    (select priority
     from scheduling_specification_goals ssg
     where ssg.specification_id = new.specification_id
     order by priority desc
     limit 1), -1) + 1
  into next_priority;

  if new.priority > next_priority then
    raise numeric_value_out_of_range using
      message = ('Updated priority % for specification_id % is not consecutive', new.priority, new.specification_id),
      hint = ('The next available priority is %.', next_priority);
  end if;

  if new.priority > old.priority then
    update scheduling_specification_goals
    set priority = priority - 1
    where specification_id = new.specification_id
      and priority between old.priority + 1 and new.priority
      and goal_id != new.goal_id;
  else
    update scheduling_specification_goals
    set priority = priority + 1
    where specification_id = new.specification_id
      and priority between new.priority and old.priority - 1
      and goal_id != new.goal_id;
  end if;
  return new;
end;
$$;

create or replace function delete_scheduling_specification_goal_func()
  returns trigger
  language plpgsql as $$
begin
  update scheduling_specification_goals
  set priority = priority - 1
  where specification_id = old.specification_id
    and priority > old.priority;
  return null;
end;
$$;

create function increment_spec_revision_on_goal_spec_update()
  returns trigger
  security definer
language plpgsql as $$begin
  update scheduling_specification
  set revision = revision + 1
  where id = new.specification_id;
  return new;
end$$;

create trigger increment_revision_on_goal_update
  before insert or update on scheduling_specification_goals
  for each row
  execute function increment_spec_revision_on_goal_spec_update();

create function increment_spec_revision_on_goal_spec_delete()
  returns trigger
  security definer
language plpgsql as $$begin
  update scheduling_specification
  set revision = revision + 1
  where id = old.specification_id;
  return old;
end$$;

create trigger increment_revision_on_goal_delete
  before delete on scheduling_specification_goals
  for each row
  execute function increment_spec_revision_on_goal_spec_delete();

/*
SCHEDULING SPECIFICATION
*/
drop trigger increment_revision_on_goal_update on scheduling_goal;
drop function increment_revision_on_goal_update();

/*
DATA MIGRATION
*/
insert into scheduling_goal_metadata(id, name, description, public, owner, updated_by, created_at, updated_at)
select id, name, description, false, author, last_modified_by, created_date, modified_date
from scheduling_goal;

insert into scheduling_goal_definition(goal_id, definition, author, created_at)
select id, definition, author, modified_date
from scheduling_goal;

insert into scheduling_model_specification_goals(model_id, goal_id)
select model_id, id
from scheduling_goal;

/*
POST DATA MIGRATION TABLE CHANGES
*/
alter table scheduling_goal_metadata
  alter column id set generated always;

alter table scheduling_specification_goals
  drop constraint scheduling_specification_goals_references_scheduling_goals,
  add constraint scheduling_spec_goal_exists
    foreign key (goal_id)
      references scheduling_goal_metadata
      on update cascade
      on delete restrict,
  add constraint scheduling_spec_goal_definition_exists
    foreign key (goal_id, goal_revision)
      references scheduling_goal_definition
      on update cascade
      on delete restrict;

create function scheduling_goal_metadata_set_updated_at()
returns trigger
security definer
language plpgsql as $$begin
  new.updated_at = now();
  return new;
end$$;

create trigger set_timestamp
before update on scheduling_goal_metadata
for each row
execute function scheduling_goal_metadata_set_updated_at();

/*
TAGS
*/
alter table metadata.scheduling_goal_tags
drop constraint scheduling_goal_tags_goal_id_fkey,
add foreign key (goal_id) references public.scheduling_goal_metadata
    on update cascade
    on delete cascade;

create table metadata.scheduling_goal_definition_tags (
  goal_id integer not null,
  goal_revision integer not null,
  tag_id integer not null,
  primary key (goal_id, goal_revision, tag_id),
  foreign key (goal_id, goal_revision) references scheduling_goal_definition
    on update cascade
    on delete cascade
);

comment on table metadata.scheduling_goal_definition_tags is e''
  'The tags associated with a specific scheduling condition definition.';

/*
SCHEDULING REQUEST
*/
/* These FKs are dropped ahead of the pkey swap to remove the dependency on analysisId's index */
alter table scheduling_goal_analysis_satisfying_activities
  drop constraint satisfying_activities_references_scheduling_request;
alter table scheduling_goal_analysis_created_activities
  drop constraint created_activities_references_scheduling_request;
alter table scheduling_goal_analysis
  drop constraint scheduling_goal_analysis_references_scheduling_request;

alter table scheduling_request
  add column plan_revision integer not null default -1,
  add column horizon_start timestamptz,
  add column horizon_end timestamptz,
  add column simulation_arguments jsonb not null default '{}',
  drop constraint scheduling_request_primary_key,
  add constraint scheduling_request_pkey primary key(analysis_id),
  drop constraint scheduling_request_analysis_unique,
  add constraint scheduling_request_unique
    unique (specification_id, specification_revision, plan_revision),
  add constraint start_before_end
    check (horizon_start <= horizon_end);

-- Insert values from the current config for the horizon
-- This is fine as temporal subset scheduling isn't really a feature
update scheduling_request
  set horizon_start = s.horizon_start,
      horizon_end = s.horizon_end
from scheduling_specification s
where s.id = scheduling_request.specification_id;

-- Drop defaults
alter table scheduling_request
  alter column plan_revision drop default,
  alter column horizon_start set not null,
  alter column horizon_end set not null,
  alter column simulation_arguments drop default ;

comment on column scheduling_request.dataset_id is e''
  'The dataset containing the final simulation results for the simulation. NULL if no simulations were run during scheduling.';
comment on column scheduling_request.plan_revision is e''
  'The revision of the plan corresponding to the given revision of the dataset.';
comment on column scheduling_request.reason is e''
  'The reason for failure in the event a scheduling request fails.';
comment on column scheduling_request.canceled is e''
  'Whether the scheduling run has been marked as canceled.';
comment on column scheduling_request.horizon_start is e''
  'The start of the scheduling and simulation horizon for this scheduling run.';
comment on column scheduling_request.horizon_end is e''
  'The end of the scheduling and simulation horizon for this scheduling run.';
comment on column scheduling_request.simulation_arguments is e''
  'The arguments simulations run during the scheduling run will use.';

/* Restore dropped FKs */
alter table scheduling_goal_analysis_satisfying_activities
  add constraint satisfying_activities_references_scheduling_request
    foreign key (analysis_id)
      references scheduling_request (analysis_id)
      on update cascade
      on delete cascade;

alter table scheduling_goal_analysis_created_activities
  add constraint created_activities_references_scheduling_request
    foreign key (analysis_id)
      references scheduling_request (analysis_id)
      on update cascade
      on delete cascade;

alter table scheduling_goal_analysis
  add constraint scheduling_goal_analysis_references_scheduling_request
    foreign key (analysis_id)
      references scheduling_request (analysis_id)
      on update cascade
      on delete cascade;

create or replace function notify_scheduler_workers ()
returns trigger
security definer
language plpgsql as $$
begin
  perform (
    with payload(specification_revision,
                 plan_revision,
                 specification_id,
                 analysis_id) as
    (
      select NEW.specification_revision,
             NEW.plan_revision,
             NEW.specification_id,
             NEW.analysis_id
    )
    select pg_notify('scheduling_request_notification', json_strip_nulls(row_to_json(payload))::text)
    from payload
  );
  return null;
end$$;

/*
ANALYSIS TABLES
*/
/* Dropped FKs are restored first */
/* 0 is the initial default as all revisions will be at 0 by this point in the migration */
alter table scheduling_goal_analysis
  add column goal_revision integer not null default 0,
  drop constraint scheduling_goal_analysis_primary_key,
  add constraint scheduling_goal_analysis_primary_key
    primary key (analysis_id, goal_id, goal_revision),
  drop constraint scheduling_goal_analysis_references_scheduling_goal,
  add constraint scheduling_goal_analysis_references_scheduling_goal
    foreign key (goal_id, goal_revision)
      references scheduling_goal_definition
      on update cascade
      on delete cascade;
alter table scheduling_goal_analysis
  alter column goal_revision drop default;

comment on column scheduling_goal_analysis.goal_revision is e''
  'The associated version of the goal definition used.';

alter table scheduling_goal_analysis_created_activities
  add column goal_revision integer not null default 0,
  drop constraint created_activities_primary_key,
  add constraint created_activities_primary_key
    primary key (analysis_id, goal_id, goal_revision, activity_id),
  drop constraint created_activities_references_scheduling_goal,
  add constraint created_activities_references_scheduling_goal
    foreign key (goal_id, goal_revision)
      references scheduling_goal_definition
      on update cascade
      on delete cascade;
alter table scheduling_goal_analysis_created_activities
  alter column goal_revision drop default;

comment on column scheduling_goal_analysis_created_activities.goal_revision is e''
  'The associated version of the goal definition used.';

alter table scheduling_goal_analysis_satisfying_activities
  add column goal_revision integer not null default 0,
  drop constraint satisfying_activities_primary_key,
  add constraint satisfying_activities_primary_key
    primary key (analysis_id, goal_id, goal_revision, activity_id),
  drop constraint satisfying_activities_references_scheduling_goal,
  add constraint satisfying_activities_references_scheduling_goal
    foreign key (goal_id, goal_revision)
      references scheduling_goal_definition
      on update cascade
      on delete cascade;
alter table scheduling_goal_analysis_satisfying_activities
  alter column goal_revision drop default;

comment on column scheduling_goal_analysis_satisfying_activities.goal_revision is e''
  'The associated version of the goal definition used.';

/*
DROP ORIGINAL
*/
drop trigger update_logging_on_update_scheduling_goal_trigger on scheduling_goal;
drop function update_logging_on_update_scheduling_goal();
drop table scheduling_goal;

call migrations.mark_migration_applied('13');
