create type activity_change_type as enum ('none', 'add', 'delete','modify');
create type conflict_resolution as enum ('none','supplying', 'receiving');

/*
Stores all of the activities associated with a merge
Gets added to by:
    - taking the diff of the supplier and receiver and uploading all non-conflicting changes with relevant tag
      -  (conflicting ids go into the conflicting activity tables)
    - uploading a resolved conflict with either the tag 'delete' or 'modify' depending on context
      -  (none and add cannot cause conflict)
      -  (a new version of the conflict resolution will replace the version currently in the table
    - deletes are placed as the full activity, but are 'marked to delete' essentially
-- Because of this, to get the full list of activities involved in an in-progress merge requires querying here and conflicting_activities
 */
-- TODO: Consider removing some of the defaults from this table? Decision depends on if we can have an activity
--        that doesn't have a field in this area somehow.
create table merge_staging_area(
    request_id integer,
    activity_id integer generated by default as identity,

    name text,
    tags text[] default '{}',
    source_scheduling_goal_id integer,
    created_at timestamptz not null,
    start_offset interval not null,
    type text not null,
    arguments merlin_argument_set not null,
    metadata merlin_activity_directive_metadata_set default '{}'::jsonb,

    change_type activity_change_type not null,

    constraint staging_area_natural_key
      primary key (activity_id, request_id),
    constraint staging_area_owned_by_merge_request
      foreign key (request_id)
      references merge_request
      on update cascade
      on delete cascade,
    constraint staging_area_start_offset_is_nonnegative
      check (start_offset >= '0')
);

-- Stores a list of all activities in conflict in a merge
create table conflicting_activities(
      merge_request_id integer,
      activity_id integer,
      change_type_supplying activity_change_type not null,
      change_type_receiving activity_change_type not null,
      resolution conflict_resolution default 'none'
);

create or replace function get_merge_base(plan_id_receiving_changes integer, snapshot_id_supplying_changes integer)
  returns integer
  language plpgsql as $$
  declare
    result integer;
begin
  select * from
    (
      select get_snapshot_history_from_plan(plan_id_receiving_changes) as ids
      intersect
      select get_snapshot_history(snapshot_id_supplying_changes) as ids
    )
    as ids
    order by ids desc
    limit 1
    into result;
  return result;
end
$$;

/*
  Plans are merged following a three way merge (https://en.wikipedia.org/wiki/Merge_(version_control)#Three-way_merge)
  algorithm. After beginning a merge, the activities will be placed into one of two areas:
  a Merge Staging Area (MSA) and a Conflicting Activities table (CA).

  Where they will go is decided as follows:

  Difference btwn Source and MB | Difference btwn Target and MB | Outcome
  ------------------------------+-------------------------------+--------------------
            Add                 |             --                | Into MSA as Add
            --                  |             Add               | Into MSA as None
            None                |             None              | Into MSA as None
            Modify              |             None              | Into MSA as Modify
            Delete              |             None              | Into MSA as Delete
            None                |             Modify            | Into MSA as None
            Modify (Equal)      |             Modify (Equal)    | Into MSA as None
            Modify (Inequal)    |             Modify (Inequal)  | Into CA
            Delete              |             Modify            | Into CA
            None                |             Delete            | Dropped
            Modify              |             Delete            | Into CA
            Delete              |             Delete            | Dropped
 */
create or replace procedure begin_merge(merge_request_id integer)
  language plpgsql as $$
  declare
    validate_id integer;
    validate_status merge_request_status;
    snapshot_id_supplying integer;
    plan_id_receiving integer;
    merge_base_id integer;
begin
  -- validate id and status
  select id, status
    from merge_request
    where merge_request_id = id
    into validate_id, validate_status;

  if validate_id is null then
    raise exception 'Request ID % is not present in merge_request table.', merge_request_id;
  end if;

  if validate_status != 'pending' then
    raise exception 'Cannot begin request. Merge request % is not in pending state.', merge_request_id;
  end if;

  -- select from merge-request the snapshot_sc (s_sc) and plan_rc (p_rc) ids
  select plan_id_receiving_changes, snapshot_id_supplying_changes
    from merge_request
    where id = merge_request_id
    into plan_id_receiving, snapshot_id_supplying;

  -- ensure the plan receiving changes isn't locked
  if (select is_locked from plan where plan.id=plan_id_receiving) then
    raise exception 'Cannot begin merge request. Plan to receive changes is locked.';
  end if;

  -- lock plan_rc
  update plan
    set is_locked = true
    where plan.id = plan_id_receiving;

  -- get merge base (mb)
  select get_merge_base(plan_id_receiving, snapshot_id_supplying)
  into merge_base_id;

  -- update the status to "in progress"
  update merge_request
    set status = 'in-progress',
    merge_base_snapshot_id = merge_base_id
    where id = merge_request_id;


  -- perform diff between mb and s_sc (s_diff)
    -- delete is B minus A on key
    -- add is A minus B on key
    -- A intersect B is no op
    -- A minus B on everything except everything currently in the table is modify
  create temp table supplying_diff(
    activity_id integer,
    change_type activity_change_type not null
  );

  insert into supplying_diff (activity_id, change_type)
  select activity_id, 'delete'
  from(
    select id as activity_id
    from plan_snapshot_activities
      where snapshot_id = merge_base_id
    except
    select id as activity_id
    from plan_snapshot_activities
      where snapshot_id = snapshot_id_supplying) a;

  insert into supplying_diff (activity_id, change_type)
  select activity_id, 'add'
  from(
    select id as activity_id
    from plan_snapshot_activities
      where snapshot_id = snapshot_id_supplying
    except
    select id as activity_id
    from plan_snapshot_activities
      where snapshot_id = merge_base_id) a;

  insert into supplying_diff (activity_id, change_type)
    select activity_id, 'none'
      from(
        select id as activity_id, name, tags, source_scheduling_goal_id, created_at, last_modified_at,
            start_offset, type, arguments, last_modified_arguments_at, metadata
        from plan_snapshot_activities
        where snapshot_id = merge_base_id
    intersect
      select id as activity_id, name, tags, source_scheduling_goal_id, created_at, last_modified_at,
            start_offset, type, arguments, last_modified_arguments_at, metadata
        from plan_snapshot_activities
        where snapshot_id = snapshot_id_supplying) a;

  insert into supplying_diff (activity_id, change_type)
    select activity_id, 'modify'
    from(
      select id as activity_id from plan_snapshot_activities
        where snapshot_id = merge_base_id or snapshot_id = snapshot_id_supplying
      except
      select activity_id from supplying_diff) a;

  -- perform diff between mb and p_rc (r_diff)
  create temp table receiving_diff(
     activity_id integer,
     change_type activity_change_type not null
  );

  insert into receiving_diff (activity_id, change_type)
  select activity_id, 'delete'
  from(
        select id as activity_id
        from plan_snapshot_activities
        where snapshot_id = merge_base_id
        except
        select id as activity_id
        from activity_directive
        where plan_id = plan_id_receiving) a;

  insert into receiving_diff (activity_id, change_type)
  select activity_id, 'add'
  from(
        select id as activity_id
        from activity_directive
        where plan_id = plan_id_receiving
        except
        select id as activity_id
        from plan_snapshot_activities
        where snapshot_id = merge_base_id) a;

  insert into receiving_diff (activity_id, change_type)
  select activity_id, 'none'
  from(
        select id as activity_id, name, tags, source_scheduling_goal_id, created_at, last_modified_at,
               start_offset, type, arguments, last_modified_arguments_at, metadata
        from plan_snapshot_activities
        where snapshot_id = merge_base_id
        intersect
        select id as activity_id, name, tags, source_scheduling_goal_id, created_at, last_modified_at,
               start_offset, type, arguments, last_modified_arguments_at, metadata
        from activity_directive
        where plan_id = plan_id_receiving) a;

  insert into receiving_diff (activity_id, change_type)
  select activity_id, 'modify'
  from (
        (select id as activity_id
         from plan_snapshot_activities
         where snapshot_id = merge_base_id
         union
         select id as activity_id
         from activity_directive
         where plan_id = plan_id_receiving)
        except
        select activity_id
        from receiving_diff) a;


  -- perform diff between s_diff and r_diff
      -- upload the non-conflicts into merge_staging_area
      -- upload conflict into conflicting_activities
  create temp table diff_diff(
    activity_id integer,
    change_type_supplying activity_change_type not null,
    change_type_receiving activity_change_type not null
  );

  -- this is going to require us to do the "none" operation again on the remaining modifies
  -- but otherwise we can just dump the 'adds' and 'none' into the merge staging area table

  -- 'delete' against a 'delete' does not enter the merge staging area table
  -- receiving 'delete' against supplying 'none' does not enter the merge staging area table

  insert into merge_staging_area (
         request_id, activity_id, name, tags,  source_scheduling_goal_id, created_at,
         start_offset, type, arguments, metadata, change_type
         )
  -- 'adds' can go directly into the merge staging area table
  select merge_request_id, activity_id, name, tags,  source_scheduling_goal_id, created_at,
         start_offset, type, arguments, metadata, change_type
    from supplying_diff as  s_diff
    join plan_snapshot_activities psa
      on s_diff.activity_id = psa.id
    where snapshot_id = snapshot_id_supplying and change_type = 'add'
  union
  -- an 'add' between the receiving plan and merge base is actually a 'none'
  select merge_request_id, activity_id, name, tags,  source_scheduling_goal_id, created_at,
         start_offset, type, arguments, metadata, 'none'::activity_change_type
    from receiving_diff as r_diff
    join activity_directive ad
      on r_diff.activity_id = ad.id
    where plan_id = plan_id_receiving and change_type = 'add';

  -- put the rest in diff_diff
  insert into diff_diff (activity_id, change_type_supplying, change_type_receiving)
  select activity_id, supplying_diff.change_type as change_type_supplying, receiving_diff.change_type as change_type_receiving
    from receiving_diff
    join supplying_diff using (activity_id)
  where receiving_diff.change_type != 'add' or supplying_diff.change_type != 'add';

  -- ...except for that which is not recorded
  delete from diff_diff
    where (change_type_receiving = 'delete' and  change_type_supplying = 'delete')
       or (change_type_receiving = 'delete' and change_type_supplying = 'none');

  insert into merge_staging_area (
         request_id, activity_id, name, tags,  source_scheduling_goal_id, created_at,
         start_offset, type, arguments, metadata, change_type
  )
  -- receiving 'none' and 'modify' against 'none' in the supplying side go into the merge staging area as 'none'
  select merge_request_id, activity_id, name, tags,  source_scheduling_goal_id, created_at,
         start_offset, type, arguments, metadata, 'none'
    from diff_diff
    join activity_directive
      on activity_id=id
    where plan_id = plan_id_receiving
      and change_type_supplying = 'none'
      and (change_type_receiving = 'modify' or change_type_receiving = 'none')
  union
  -- supplying 'modify' against receiving 'none' go into the merge staging area as 'modify'
  select merge_request_id, activity_id, name, tags,  source_scheduling_goal_id, created_at,
         start_offset, type, arguments, metadata, change_type_supplying
    from diff_diff
    join plan_snapshot_activities p
      on diff_diff.activity_id = p.id
    where snapshot_id = snapshot_id_supplying
      and (change_type_receiving = 'none' and diff_diff.change_type_supplying = 'modify')
  union
  -- supplying 'delete' against receiving 'none' go into the merge staging area as 'delete'
    select merge_request_id, activity_id, name, tags,  source_scheduling_goal_id, created_at,
         start_offset, type, arguments, metadata, change_type_supplying
    from diff_diff
    join activity_directive p
      on diff_diff.activity_id = p.id
    where plan_id = plan_id_receiving
      and (change_type_receiving = 'none' and diff_diff.change_type_supplying = 'delete')
  union
  -- 'modify' against a 'modify' must be checked for equality first.
  select merge_request_id, activity_id, name, tags,  source_scheduling_goal_id, created_at,
         start_offset, type, arguments, metadata, 'none'
  from (
    select activity_id, name, tags,  source_scheduling_goal_id, created_at,
           start_offset, type, arguments, metadata
      from plan_snapshot_activities psa
      join diff_diff dd
        on dd.activity_id = psa.id
      where psa.snapshot_id = snapshot_id_supplying
        and (dd.change_type_receiving = 'modify' and dd.change_type_supplying = 'modify')
    intersect
    select activity_id, name, tags,  source_scheduling_goal_id, created_at,
           start_offset, type, arguments, metadata
      from diff_diff dd
      join activity_directive ad
        on dd.activity_id = ad.id
      where ad.plan_id = plan_id_receiving
        and (dd.change_type_supplying = 'modify' and dd.change_type_receiving = 'modify')
  ) a;

  -- 'modify' against 'delete' and inequal 'modify' against 'modify' goes into conflict table (aka everything left in diff_diff)
  insert into conflicting_activities (merge_request_id, activity_id, change_type_supplying, change_type_receiving)
  select begin_merge.merge_request_id, activity_id, change_type_supplying, change_type_receiving
  from (select begin_merge.merge_request_id, activity_id
        from diff_diff
        except
        select request_id, activity_id
        from merge_staging_area) a
  join diff_diff using (activity_id);

  -- clean up
  drop table supplying_diff;
  drop table receiving_diff;
  drop table diff_diff;
end
$$;

/*
  Commit merge takes all of the contents of the staging area and all of the resolved conflicts
  and applies the changes to the plan getting merged into.
 */
create or replace procedure commit_merge(request_id integer)
  language plpgsql as $$
  declare
    validate_noConflicts integer;
    plan_id_R integer;
    snapshot_id_S integer;
begin
  if(select id from merge_request where id = request_id) is null then
    raise exception 'Invalid merge request id %.', request_id;
  end if;

  -- Stop if this merge is not 'in-progress'
  if (select status from merge_request where id = request_id) != 'in-progress' then
    raise exception 'Cannot commit a merge request that is not in-progress.';
  end if;

  -- Stop if any conflicts have not been resolved
  select * from conflicting_activities
  where merge_request_id = request_id and resolution = 'none'
  limit 1
  into validate_noConflicts;

  if(validate_noConflicts is not null) then
    raise exception 'There are unresolved conflicts in merge request %. Cannot commit merge.', request_id;
  end if;

  select plan_id_receiving_changes from merge_request mr where mr.id = request_id into plan_id_R;
  select snapshot_id_supplying_changes from merge_request mr where mr.id = request_id into snapshot_id_S;

  insert into merge_staging_area(
         request_id, activity_id, name, tags, source_scheduling_goal_id, created_at,
         start_offset, type, arguments, metadata, change_type)
    -- gather delete data from the opposite tables
    select  commit_merge.request_id, activity_id, name, tags, source_scheduling_goal_id, created_at,
            start_offset, type, arguments, metadata, 'delete'::activity_change_type
      from  conflicting_activities ca
      join  activity_directive ad
        on  ca.activity_id = ad.id
      where ca.resolution = 'supplying'
        and ca.merge_request_id = commit_merge.request_id
        and plan_id = plan_id_R
        and ca.change_type_supplying = 'delete'
    union
    select  commit_merge.request_id, activity_id, name, tags, source_scheduling_goal_id, created_at,
          start_offset, type, arguments, metadata, 'delete'::activity_change_type
      from  conflicting_activities ca
      join  plan_snapshot_activities psa
        on  ca.activity_id = psa.id
      where ca.resolution = 'receiving'
        and ca.merge_request_id = commit_merge.request_id
        and snapshot_id = snapshot_id_S
        and ca.change_type_receiving = 'delete'
    union
    select  commit_merge.request_id, activity_id, name, tags, source_scheduling_goal_id, created_at,
            start_offset, type, arguments, metadata, 'none'::activity_change_type
      from  conflicting_activities ca
      join  activity_directive ad
        on  ca.activity_id = ad.id
      where ca.resolution = 'receiving'
        and ca.merge_request_id = commit_merge.request_id
        and plan_id = plan_id_R
        and ca.change_type_receiving = 'modify'
    union
    select  commit_merge.request_id, activity_id, name, tags, source_scheduling_goal_id, created_at,
          start_offset, type, arguments, metadata, 'modify'::activity_change_type
      from  conflicting_activities ca
      join  plan_snapshot_activities psa
        on  ca.activity_id = psa.id
      where ca.resolution = 'supplying'
        and ca.merge_request_id = commit_merge.request_id
        and snapshot_id = snapshot_id_S
        and ca.change_type_supplying = 'modify';

  -- Unlock so that updates can be written
  update plan
  set is_locked = false
  where id = plan_id_R;

  -- Update the plan's activities to match merge-staging-area's activities
  -- Add
  insert into activity_directive(
                id, plan_id, name, tags, source_scheduling_goal_id, created_at,
                start_offset, type, arguments, metadata )
  select  activity_id, plan_id_R, name, tags, source_scheduling_goal_id, created_at,
            start_offset, type, arguments, metadata
   from merge_staging_area
  where merge_staging_area.request_id = commit_merge.request_id
    and change_type = 'add';

  -- Modify
  update activity_directive
  set name = msa.name,
      tags = msa.tags,
      source_scheduling_goal_id = msa.source_scheduling_goal_id,
      created_at = msa.created_at,
      start_offset = msa.start_offset,
      type = msa.type,
      arguments = msa.arguments,
      metadata = msa.metadata
  from merge_staging_area msa
  where msa.request_id = commit_merge.request_id
    and activity_directive.plan_id = plan_id_R
    and msa.change_type = 'modify'
    and id = msa.activity_id;

  -- Delete
  delete from activity_directive ad
  using merge_staging_area msa
  where ad.id = msa.activity_id
    and ad.plan_id = plan_id_R
    and msa.request_id = commit_merge.request_id
    and msa.change_type = 'delete';

  -- Clean up
  delete from conflicting_activities where merge_request_id = request_id;
  delete from merge_staging_area where merge_staging_area.request_id = commit_merge.request_id;

  update merge_request
  set status = 'accepted'
  where id = request_id;

  -- Attach snapshot history
  insert into plan_latest_snapshot(plan_id, snapshot_id)
  select plan_id_receiving_changes, snapshot_id_supplying_changes
  from merge_request
  where id = request_id;
end
$$;

/*
  - Discard everything that was in the staging area
  - Then, unlock the to-be-edited plan
  - Then, change the merge request's status to 'rejected'
*/
create or replace procedure deny_merge(request_id integer)
  language plpgsql as $$
  begin
    if(select id from merge_request where id = request_id) is null then
      raise exception 'Invalid merge request id %.', request_id;
    end if;

    if (select status from merge_request where id = request_id) != 'in-progress' then
      raise exception 'Cannot reject merge not in progress.';
    end if;

    delete from conflicting_activities where merge_request_id = request_id;
    delete from merge_staging_area where merge_staging_area.request_id = deny_merge.request_id;

    update merge_request
    set status = 'rejected'
    where merge_request.id = request_id;

    update plan
    set is_locked = false
    where plan.id = (select plan_id_receiving_changes from merge_request where id = request_id);
  end
  $$;

/*
  - Discard everything that was in the staging area
  - Then, unlock the to-be-edited plan
  - Then, change the merge request's status to 'pending'
*/
create or replace procedure cancel_merge(request_id integer)
  language plpgsql as $$
  declare
    verify_status merge_request_status;
begin
    if(select id from merge_request where id = request_id) is null then
      raise exception 'Invalid merge request id %.', request_id;
    end if;

    select status from merge_request where id = request_id into verify_status;
    if not (verify_status = 'in-progress' or verify_status = 'pending') then
      raise exception 'Cannot cancel merge.';
    end if;

    delete from conflicting_activities where merge_request_id = request_id;
    delete from merge_staging_area where merge_staging_area.request_id = cancel_merge.request_id;

    update merge_request
    set status = 'pending'
    where merge_request.id = request_id;

    update plan
    set is_locked = false
    where plan.id = (select plan_id_receiving_changes from merge_request where id = request_id);
end
$$;

create view merge_review_activity as
select merge_request_id,
       activity_id,
       change_type_supplying as change_type_source,
       change_type_receiving as change_type_target,
       case resolution
         when 'supplying'
           then 'source'
         when 'receiving'
           then 'target'
         end as resolution,
       snap_act as source,
       act as target,
       'true'::boolean as is_conflict
from conflicting_activities c
       join merge_request m on c.merge_request_id = m.id
       left join plan_snapshot_activities snap_act on m.snapshot_id_supplying_changes = snap_act.snapshot_id and c.activity_id = snap_act.id
       left join activity_directive act on m.plan_id_receiving_changes = act.plan_id and c.activity_id = act.id
union all
select request_id as merge_request_id,
       activity_id,
       change_type as change_type_source,
       'none' as change_type_target,
       'source' as resolution,
       snap_act as source,
       act as target,
       'false'::boolean as is_conflict
from merge_staging_area msa
       join merge_request m on msa.request_id = m.id
       left join plan_snapshot_activities snap_act on m.snapshot_id_supplying_changes = snap_act.snapshot_id and msa.activity_id = snap_act.id
       left join activity_directive act on m.plan_id_receiving_changes = act.plan_id and msa.activity_id = act.id
where not (change_type = 'none');
