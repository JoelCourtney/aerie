create type anchor_type as enum ('activity', 'event', 'plan');

create table activity_directive
(
  id integer generated by default as identity,
  plan_id integer not null,

  name text,
  tags text[] default '{}',
  source_scheduling_goal_id integer,
  created_at timestamptz not null default now(),
  last_modified_at timestamptz not null default now(),
  start_offset interval not null,
  -- anchor_type anchor_type not null default 'plan',
  -- anchored_to_start boolean not null default true,
  -- anchor_id integer not null default plan_id,
  -- is_event boolean not null default false,
  type text not null,
  arguments merlin_argument_set not null,
  last_modified_arguments_at timestamptz not null default now(),
  metadata merlin_activity_directive_metadata_set default '{}'::jsonb,

  constraint activity_directive_natural_key
    primary key (id, plan_id),
  constraint activity_directive_owned_by_plan
    foreign key (plan_id)
      references plan
      on update cascade
      on delete cascade,
  constraint activity_directive_start_offset_is_nonnegative
    check (start_offset >= '0')
);

create index activity_directive_plan_id_index on activity_directive (plan_id);


comment on table activity_directive is e''
  'A single activity_directive within a plan.';

comment on column activity_directive.id is e''
  'The synthetic identifier for this activity_directive.\n'
  'Unique within a given plan.';
comment on column activity_directive.plan_id is e''
  'The plan within which this activity_directive is located.';
comment on column activity_directive.name is e''
  'The name of this activity_directive.';
comment on column activity_directive.tags is e''
  'The tags associated with this activity_directive.';
comment on column activity_directive.source_scheduling_goal_id is e''
  'The scheduling goal that this activity_directive was generated by.';
comment on column activity_directive.created_at is e''
  'The time at which this activity_directive was created.';
comment on column activity_directive.last_modified_at is e''
  'The time at which this activity_directive was last modified.';
comment on column activity_directive.last_modified_arguments_at is e''
  'The time at which this activity_directive.arguments was last modified.';
comment on column activity_directive.start_offset is e''
  'The non-negative time offset from the start of the plan at which this activity_directive is scheduled.';
comment on column activity_directive.type is e''
  'The type of the activity_directive, as defined in the mission model associated with the plan.';
comment on column activity_directive.arguments is e''
  'The set of arguments to this activity_directive, corresponding to the parameters of the associated activity type.';
comment on column activity_directive.metadata is e''
  'The metadata associated with this activity_directive.';

create procedure plan_locked_exception(plan_id integer)
language plpgsql as $$
  begin
    if(select is_locked from plan where plan.id = plan_id limit 1) then
      raise exception 'Plan % is locked.', plan_id;
    end if;
  end
$$;

create or replace procedure anchor_id_exists(anchor_type anchor_type, anchor_id integer)
language plpgsql as $$
  begin
    raise exception '%', anchor_type;
  end
$$;


comment on procedure plan_locked_exception(plan_id integer) is e''
  'Verify that the plan corresponding to the activity being updated is unlocked, throwing an exception if not.';

create function increment_revision_on_insert_activity_directive()
returns trigger
security definer
language plpgsql as $$begin
  update plan
  set revision = revision + 1
  where id = new.plan_id;

  return new;
end$$;

create trigger increment_revision_on_insert_activity_directive_trigger
after insert on activity_directive
for each row
execute function increment_revision_on_insert_activity_directive();

create function increment_revision_on_update_activity_directive()
returns trigger
security definer
language plpgsql as $$begin
  update plan
  set revision = revision + 1
  where id = new.plan_id
    or id = old.plan_id;

  return new;
end$$;

create trigger increment_revision_on_update_activity_directive_trigger
after update on activity_directive
for each row
execute function increment_revision_on_update_activity_directive();

create function increment_revision_on_delete_activity_directive()
returns trigger
security definer
language plpgsql as $$begin
  update plan
  set revision = revision + 1
  where id = old.plan_id;

  return old;
end$$;

create trigger increment_revision_on_delete_activity_directive_trigger
after delete on activity_directive
for each row
execute function increment_revision_on_delete_activity_directive();

create or replace function generate_activity_directive_name()
returns trigger
security definer
language plpgsql as $$begin
  call plan_locked_exception(new.plan_id);
  call anchor_id_exists(new.anchor_type, new.anchor_id);
  if new.name is null
  then new.name = new.type || ' ' || new.id;
  end if;
  return new;
end$$;

comment on function generate_activity_directive_name() is e''
  'Generates a name for an activity_directive as the activity type + activity id.';

create trigger generate_name_trigger
before insert on activity_directive
for each row execute function generate_activity_directive_name();

comment on trigger generate_name_trigger on activity_directive is e''
  'Generates a name for an activity_directive as the activity type + activity id.';

create or replace function activity_directive_set_updated_at()
  returns trigger
  security definer
  language plpgsql as $$begin
    call plan_locked_exception(new.plan_id);
    call anchor_id_exists(new.anchor_type, new.anchor_id);
    new.last_modified_at = now();
  return new;
end$$;

comment on function activity_directive_set_updated_at() is e''
  'Sets the last_modified_at field of an activity_directive to the current time.';

create trigger set_timestamp
  before update on activity_directive
  for each row
execute function activity_directive_set_updated_at();

comment on trigger set_timestamp on activity_directive is e''
  'Sets the last_modified_at field of an activity_directive to the current time.';

create function activity_directive_set_arguments_updated_at()
  returns trigger
  security definer
  language plpgsql as $$begin
    call plan_locked_exception(new.plan_id);
    new.last_modified_arguments_at = now();
  return new;
end$$;

comment on function activity_directive_set_arguments_updated_at() is e''
  'Sets the last_modified_arguments_at field of an activity_directive to the current time.';

create trigger set_arguments_timestamp
  before update of arguments on activity_directive
  for each row
execute function activity_directive_set_arguments_updated_at();

comment on trigger set_arguments_timestamp on activity_directive is e''
  'Sets the last_modified_arguments_at field of an activity_directive to the current time.';

create function check_activity_directive_metadata()
returns trigger
security definer
language plpgsql as $$
  declare
    _key text;
    _value jsonb;
    _schema jsonb;
    _type text;
    _subValue jsonb;
  begin
  call plan_locked_exception(new.plan_id);
  for _key, _value in
    select * from jsonb_each(new.metadata::jsonb)
  loop
    select schema into _schema from activity_directive_metadata_schema where key = _key;
    _type := _schema->>'type';
    if _type = 'string' then
      if jsonb_typeof(_value) != 'string' then
        raise exception 'invalid metadata value for key %. Expected: string, Received: %', _key, _value;
      end if;
    elsif _type = 'long_string' then
      if jsonb_typeof(_value) != 'string' then
        raise exception 'invalid metadata value for key %. Expected: string, Received: %', _key, _value;
      end if;
    elsif _type = 'boolean' then
      if jsonb_typeof(_value) != 'boolean' then
        raise exception 'invalid metadata value for key %. Expected: boolean, Received: %', _key, _value;
      end if;
    elsif _type = 'number' then
      if jsonb_typeof(_value) != 'number' then
        raise exception 'invalid metadata value for key %. Expected: number, Received: %', _key, _value;
      end if;
    elsif _type = 'enum' then
      if (_value not in (select * from jsonb_array_elements(_schema->'enumerates'))) then
        raise exception 'invalid metadata value for key %. Expected: %, Received: %', _key, _schema->>'enumerates', _value;
      end if;
    elsif _type = 'enum_multiselect' then
      if jsonb_typeof(_value) != 'array' then
        raise exception 'invalid metadata value for key %. Expected an array of enumerates: %, Received: %', _key, _schema->>'enumerates', _value;
      end if;
      for _subValue in select * from jsonb_array_elements(_value)
        loop
          if (_subValue not in (select * from jsonb_array_elements(_schema->'enumerates'))) then
            raise exception 'invalid metadata value for key %. Expected one of the valid enumerates: %, Received: %', _key, _schema->>'enumerates', _value;
          end if;
        end loop;
    end if;
  end loop;
  return new;
end$$;

create trigger check_activity_directive_metadata_trigger
before insert or update on activity_directive
for each row
execute function check_activity_directive_metadata();

create function check_locked_on_delete()
  returns trigger
  security definer
  language plpgsql as $$
  begin
    call plan_locked_exception(old.plan_id);
    return old;
  end $$;

create trigger check_locked_on_delete_trigger
before delete on activity_directive
for each row
execute procedure check_locked_on_delete();
